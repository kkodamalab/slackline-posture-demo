<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Posture Demo - MediaPipe</title>
<style>
  body { margin: 0; background: #111; color: #fff; font-family: sans-serif; }
  #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
  video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
  #info {
    position: absolute; bottom: 10px; left: 10px;
    background: rgba(0,0,0,0.4); padding: 10px;
    border-radius: 6px; font-size: 18px;
  }
</style>
</head>
<body>

<div id="container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="info">Deviation: 0 px</div>
</div>

<!-- MediaPipe Task API -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"></script>

<script>
(async () => {
  // DOM
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const info = document.getElementById("info");

  // カメラ設定（USBカメラも自動認識）
  navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
    video.srcObject = stream;
  });

  // MediaPipe Pose
  const vision = await window.FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
  );

  const pose = await window.PoseLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task"
    },
    runningMode: "video",
    numPoses: 1
  });

  function draw() {
    if (video.readyState < 2) {
      requestAnimationFrame(draw);
      return;
    }

    // Canvasサイズを合わせる
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // Detect pose
    pose.detectForVideo(video, performance.now(), result => {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // 正中線（画面中央に縦線）
      const midX = canvas.width / 2;
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(midX, 0);
      ctx.lineTo(midX, canvas.height);
      ctx.stroke();

      if (result.landmarks && result.landmarks.length > 0) {
        const lm = result.landmarks[0];

        // 肩と腰の位置（左右の平均）
        function avg(a, b) {
          return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
        }

        const leftShoulder = lm[11];
        const rightShoulder = lm[12];
        const shoulderMid = avg(leftShoulder, rightShoulder);

        const leftHip = lm[23];
        const rightHip = lm[24];
        const hipMid = avg(leftHip, rightHip);

        // Canvas座標に変換
        function toCanvas(p) {
          return {
            x: p.x * canvas.width,
            y: p.y * canvas.height
          };
        }

        const s = toCanvas(shoulderMid);
        const h = toCanvas(hipMid);

        // 体軸ライン（肩-腰の中点）
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(h.x, h.y);
        ctx.stroke();

        // ズレ量（px）
        const deviation = Math.abs(s.x - midX);

        // 数値表示
        info.textContent = `Deviation: ${deviation.toFixed(1)} px`;

        // ズレが大きいと赤くアラート
        if (deviation > 60) {
          info.style.background = "rgba(180,0,0,0.6)";
          info.textContent += "  ← ALERT: Off-center";
        } else {
          info.style.background = "rgba(0,0,0,0.4)";
        }
      }
    });

    requestAnimationFrame(draw);
  }

  draw();
})();
</script>

</body>
</html>