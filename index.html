<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Slackline Posture Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body {
    margin: 0;
    background: #111;
    color: #fff;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
  }
  #videoArea {
    position: relative;
    flex: 1 1 auto;
    width: 100%;
    background: #000;
  }
  video, canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform: scaleX(-1);
  }
  #info {
    flex: 0 0 auto;
    padding: 10px;
    font-size: 16px;
    background: #222;
    line-height: 1.4;
    white-space: pre-line;
  }
</style>
</head>
<body>

<div id="videoArea">
  <video id="video" autoplay playsinline muted></video>
  anvas id="canvas"></canvas>
</div>
<div id="info">Loading…</div>

<script type="module">
  import {FilesetResolver, PoseLandmarker} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

  const video  = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx    = canvas.getContext("2d");
  const info   = document.getElementById("info");

  async function setupCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "user",
        width:  { ideal: 1280 },
        height: { ideal: 720 },
        aspectRatio: { ideal: 16/9 }
      },
      audio: false
    });
    video.srcObject = stream;
    return new Promise(resolve => {
      video.onloadedmetadata = () => resolve();
    });
  }

  function computeAxisAndAngle(lm) {
    const avg = (a, b) => ({
      x: (a.x + b.x) / 2,
      y: (a.y + b.y) / 2
    });

    const s = avg(lm[11], lm[12]); // shoulders
    const h = avg(lm[23], lm[24]); // hips

    return {s, h};
  }

  async function main() {
    try {
      await setupCamera();

      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task"
        },
        runningMode: "VIDEO",
        numPoses: 1,
        minPoseDetectionConfidence: 0.5,
        minPosePresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      info.textContent = "Pose loaded. Step back so your full body is visible.";

      let lastVideoTime = -1;

      function renderLoop() {
        if (video.readyState < 2) {
          requestAnimationFrame(renderLoop);
          return;
        }

        if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
          canvas.width  = video.videoWidth;
          canvas.height = video.videoHeight;
        }

        if (video.currentTime === lastVideoTime) {
          requestAnimationFrame(renderLoop);
          return;
        }
        lastVideoTime = video.currentTime;

        const nowMs = performance.now();
        const result = poseLandmarker.detectForVideo(video, nowMs);

        // Background
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
        ctx.restore();

        const midX = canvas.width / 2;
        ctx.strokeStyle = "yellow";
        ctx.lineWidth   = 3;
        ctx.beginPath();
        ctx.moveTo(midX, 0);
        ctx.lineTo(midX, canvas.height);
        ctx.stroke();

        if (!result || !result.landmarks || result.landmarks.length === 0) {
          info.textContent = "Detecting… (Step back so your full body is visible)";
          requestAnimationFrame(renderLoop);
          return;
        }

        const lm = result.landmarks[0];
        const {s, h} = computeAxisAndAngle(lm);

        // Normalized → Pixels + Mirror flip
        let sx = s.x * canvas.width;
        let sy = s.y * canvas.height;
        let hx = h.x * canvas.width;
        let hy = h.y * canvas.height;

        // Mirror correction (match video display)
        sx = canvas.width - sx;
        hx = canvas.width - hx;

        // Body axis line (shoulders → hips)
        ctx.strokeStyle = "cyan";
        ctx.lineWidth   = 4;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(hx, hy);
        ctx.stroke();

        const vx = hx - sx;
        const vy = hy - sy;
        const len = Math.hypot(vx, vy) || 1;
        const nx = vx / len;
        const ny = vy / len;

        let deg = Math.acos(Math.max(-1, Math.min(1, -ny))) * 180 / Math.PI;
        if (nx > 0) deg = +deg; else deg = -deg;

        const direction = (deg > 0) ? "Right" : "Left";
        const deviationDeg = Math.abs(deg).toFixed(1);

        info.textContent =
          `Pose detected.\nBody axis tilt: ${direction} ${deviationDeg}°\nIdeal posture is vertical (0°). Adjust your balance.`;

        requestAnimationFrame(renderLoop);
      }

      renderLoop();
    } catch (e) {
      console.error(e);
      info.textContent = "Error: " + (e && e.message ? e.message : e);
    }
  }

  main();
</script>

</body>
</html>
