<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Posture Demo - MediaPipe</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body {
    margin: 0;
    background: #111;
    color: #fff;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
  }
  #videoArea {
    position: relative;
    flex: 1 1 auto;
    width: 100%;
    background: #000;
  }
  video, canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;  /* 縦長画面で全画面表示 */
    transform: scaleX(-1); /* インカメラ用に左右反転（不要なら削除） */
  }
  #info {
    flex: 0 0 auto;
    padding: 10px;
    font-size: 18px;
    background: #222;
  }
</style>
</head>
<body>

<div id="videoArea">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
</div>
<div id="info">Loading…</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-core@0.10.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>

<script>
(async () => {
  const video  = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx    = canvas.getContext("2d");
  const info   = document.getElementById("info");

  // --- カメラ（縦長寄りの比率を要求） ---
  const stream = await navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: "user",
      width:  { ideal: 720 },
      height: { ideal: 1280 },
      aspectRatio: { ideal: 9/16 }  // ポートレート向き比率を要求
    },
    audio: false
  });
  video.srcObject = stream;

  // --- MediaPipe 初期化 ---
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
  );

  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task"
    },
    runningMode: "VIDEO",
    numPoses: 1,
    minPoseDetectionConfidence: 0.5,
    minPosePresenceConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  info.textContent = "Pose loaded. Move into view.";

  let lastVideoTime = -1;

  function renderLoop() {
    if (video.readyState < 2) {
      requestAnimationFrame(renderLoop);
      return;
    }

    // video の実サイズに合わせて canvas を更新
    if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    // 新しいフレームのときだけ推定
    if (video.currentTime === lastVideoTime) {
      requestAnimationFrame(renderLoop);
      return;
    }
    lastVideoTime = video.currentTime;

    const nowMs = performance.now();
    const result = poseLandmarker.detectForVideo(video, nowMs);

    // まず背景としてビデオ
    ctx.save();
    // video は左右反転して draw する（CSS と合わせる）
    ctx.scale(-1, 1);
    ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
    ctx.restore();

    // 中央ライン
    const midX = canvas.width / 2;
    ctx.strokeStyle = "yellow";
    ctx.lineWidth   = 3;
    ctx.beginPath();
    ctx.moveTo(midX, 0);
    ctx.lineTo(midX, canvas.height);
    ctx.stroke();

    // ランドマークがないとき
    if (!result || !result.landmarks || result.landmarks.length === 0) {
      info.textContent = "Detecting…（身体をカメラ中央に）";
      requestAnimationFrame(renderLoop);
      return;
    }

    info.textContent = "Pose detected.";

    const lm = result.landmarks[0]; // 33点

    // 肩と腰の中点
    const avg = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });

    const s = avg(lm[11], lm[12]);  // shoulders
    const h = avg(lm[23], lm[24]);  // hips

    // 正規化座標(0-1)→ピクセル
    s.x *= canvas.width;  s.y *= canvas.height;
    h.x *= canvas.width;  h.y *= canvas.height;

    // スケルトン線（肩-腰）
    ctx.strokeStyle = "cyan";
    ctx.lineWidth   = 4;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(h.x, h.y);
    ctx.stroke();

    const deviation = Math.abs(s.x - midX);
    info.textContent = `Deviation: ${deviation.toFixed(1)} px`;

    requestAnimationFrame(renderLoop);
  }

  renderLoop();
})();
</script>

</body>
</html>
